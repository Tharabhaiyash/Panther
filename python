from __future__ import with_statement
import subprocess
import sys
import speech_recognition as sr
import datetime
import wikipedia
import webbrowser
import os
import pyautogui
import time
import pygetwindow as gw
import pytesseract
from PIL import Image
import tkinter as tk
import winsound
import keyboard
import random
import subprocess
import mediapipe as mp
import cv2
from elevenlabs import set_api_key, Voice, VoiceSettings, generate
import random
from io import BytesIO
import json
from tkinter import simpledialog
import pyttsx3
import requests
import pygame
import re

# Set your API key
set_api_key("58f6af9732a0cecb1afc98c957ee4375")
api_key = 'xgoEFR7ipk0OgHfhKmDoRw==wg9mHBoogyV6gXeh'
eden_api = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoiYWZmNzRmODEtMjFmYy00Y2VmLWFjNGEtN2U2YzU5ODBiNWM0IiwidHlwZSI6ImFwaV90b2tlbiJ9.oHVLqyzWBQQzn4sH52a6AtuhbZATWR9LZcdGUkZ7VL8'

# Voice model IDs
michel_voice_id = 'flq6f7yk4E4fJM5XTYuZ' 
glinda_voice_id ='z9fAnlkpzviPz146aGWa' 
lily_voice_id = 'pFZP5JQG7iQjIQuC4Bku'
# Function to generate audio using Seven Eleven Labs API
def generate_audio(text, voice_model):
    return generate(
        text=text,
        voice=Voice(
            voice_id=voice_model,
            settings=VoiceSettings(stability=0.71, similarity_boost=0.5, style=0.0, use_speaker_boost=True)
        )
    )

# Function to play audio using pygame
def play_audio(audio):
    pygame.mixer.init()
    audio_stream = BytesIO(audio)
    pygame.mixer.music.load(audio_stream)
    pygame.mixer.music.play()
    while pygame.mixer.music.get_busy():
        pygame.time.Clock().tick(10)

def speak(audio, voice_model=None):
    if voice_model is None:
        voice_model = michel_voice_id

    # Print the full text regardless of its length
    print(audio)
    
    # Limit the speech to the first 40 words
    limited_audio = ' '.join(audio.split()[:40])
    
    audio_data = generate_audio(limited_audio, voice_model)
    play_audio(audio_data)

terminate_loop = False  # Variable to control loop termination

# Function to greet the user based on the time of day
def wishMe():
    hour = int(datetime.datetime.now().hour)
    if 0 <= hour < 12:
        speak("Good Morning sir, how may I assist you?", michel_voice_id)
    elif 12 <= hour < 18:
        speak("Good Afternoon sir, how may I assist you?", michel_voice_id)
    else:
        speak("Good Evening sir, how may I assist you?", michel_voice_id)

#**********************************************************//////////////////////////////////////////////////////

# Define a flag to control whether the assistant is active or not
assistant_active = True

#required for tessaract
pytesseract.pytesseract.tesseract_cmd = r'C:\Users\jeetu\AppData\Local\Programs\Tesseract-OCR\tesseract.exe'

# Initialize the tkinter root window (you can also create a function for this)
root = tk.Tk()
root.withdraw()  # Hide the main window

# Disable the fail-safe mechanism
pyautogui.FAILSAFE = False
    
def fetch_joke(api_key):
    """Fetch a joke from the API and return it."""
    limit = 1  # Fetch only one joke
    api_url = f'https://api.api-ninjas.com/v1/jokes?limit={limit}'
    response = requests.get(api_url, headers={'X-Api-Key': api_key})
    if response.status_code == requests.codes.ok:
        jokes = response.json()
        if jokes:
            return jokes[0]['joke']  # Return the first joke
        else:
            return "I couldn't find any jokes."
    else:
        return f"Error fetching joke: {response.status_code}"
    
def get_fact():
    limit = 3
    api_url = f'https://api.api-ninjas.com/v1/facts?limit={limit}'
    headers = {'X-Api-Key': api_key}  # Correctly reference the api_key variable
    try:
        response = requests.get(api_url, headers=headers)
        if response.status_code == 200:
            facts = response.json()  # This should be a list of facts
            # Choose a random fact from the list
            random_fact = random.choice(facts)['fact']
            return random_fact
        else:
            print(f"Error fetching fact: {response.status_code}")
            return "I couldn't fetch a fact right now."
    except Exception as e:
        print(f"Exception occurred: {e}")
        return "I encountered an error while trying to fetch a fact."

def get_historical_figure_details(name):
    """Fetch details of a historical figure using the API."""
    api_key = 'YOUR_API_KEY'  # Replace YOUR_API_KEY with your actual API key
    api_url = f'https://api.api-ninjas.com/v1/historicalfigures?name={requests.utils.quote(name)}'
    response = requests.get(api_url, headers={'X-Api-Key': api_key})
    
    if response.status_code == requests.codes.ok:
        details = response.json()
        return details
    else:
        print(f"Error fetching details: {response.status_code}")
        return [] 
    
def make_api_request(endpoint_url, params=None):
    headers = {'X-Api-Key': api_key}
    try:
        response = requests.get(endpoint_url, headers=headers, params=params)
        if response.status_code == 200:
            return response.json()
        else:
            print(f"Error with API request: {response.status_code}")
            return None
    except Exception as e:
        print(f"Exception occurred during API request: {e}")
        return None
   
categories = [
    "age", "alone", "amazing", "anger", "architecture", "art", "attitude", "beauty", "best", "birthday",
    "business", "car", "change", "communication", "computers", "cool", "courage", "dad", "dating", "death",
    "design", "dreams", "education", "environmental", "equality", "experience", "failure", "faith", "family",
    "famous", "fear", "fitness", "food", "forgiveness", "freedom", "friendship", "funny", "future", "god",
    "good", "government", "graduation", "great", "happiness", "health", "history", "home", "hope", "humor",
    "imagination", "inspirational", "intelligence", "jealousy", "knowledge", "leadership", "learning", "legal",
    "life", "love", "marriage", "medical", "men", "mom", "money", "morning", "movies", "success"
]


def get_random_quote():
    category = random.choice(categories)  # Randomly select a category
    endpoint_url = f'https://api.api-ninjas.com/v1/quotes?category={category}'
    result = make_api_request(endpoint_url)
    if result:
        # Assuming the API returns a list of quotes
        quote = result[0]['quote']  # Grab the first quote for simplicity
        author = result[0]['author']  # Assuming there's an author field
        return f"A quote on {category}: \"{quote}\" by {author}"
    else:
        return "I couldn't fetch a quote right now."

def get_and_speak_riddle(api_key):
    api_url = 'https://api.api-ninjas.com/v1/riddles'
    response = requests.get(api_url, headers={'X-Api-Key': api_key})
    if response.status_code == requests.codes.ok:
        # Parse the riddle from the response
        riddle_data = response.json()[0]  # Assuming the API returns a list of riddles
        title = riddle_data.get("title", "A riddle for you")
        question = riddle_data.get("question")
        answer = riddle_data.get("answer")
        
        # Speak out the riddle's title and question
        print(f"{title}: {question}")  # Optional: print to console
        speak(f"{title}: {question}")
        
        
        # Wait for 5 seconds before giving the answer
        time.sleep(5)
        
        # Speak out the answer
        print(f"Answer: {answer}")  # Optional: print to console
        speak(f"The answer is: {answer}")
    else:
        print("Error:", response.status_code, response.text)
        speak("I couldn't fetch a riddle right now.")

# Categories available for trivia
trivia_categories = [
    'artliterature', 'language', 'sciencenature', 'general', 'fooddrink', 
    'peopleplaces', 'geography', 'historyholidays', 'entertainment', 
    'toysgames', 'music', 'mathematics', 'religionmythology', 'sportsleisure'
]

# Function to fetch and speak trivia
def get_and_speak_trivia(api_key):
    # Randomly choose a category
    category = random.choice(trivia_categories)
    api_url = f'https://api.api-ninjas.com/v1/trivia?category={category}'
    
    # Make the API request
    response = requests.get(api_url, headers={'X-Api-Key': api_key})
    if response.status_code == requests.codes.ok:
        trivia_data = response.json()[0]  # Assuming the API returns a list of trivia
        question = trivia_data.get("question")
        answer = trivia_data.get("answer")
        
        # Speak out the trivia question
        print(f"Here's a trivia question about {category.replace('_', ' ')}: {question}")  # Optional: print to console
        speak(f"Here's a trivia question about {category.replace('_', ' ')}: {question}")
        
        # Optionally wait before giving the answer
        time.sleep(5)  # Adjust the wait time as needed
        
        # Speak out the answer
        print(f"Answer: {answer}")  # Optional: print to console
        speak(f"The answer is: {answer}")
    else:
        print("Error:", response.status_code, response.text)
        speak("I couldn't fetch trivia right now.")    

def get_recipe(api_key):
    speak("Which recipe are you looking for?")
    query = takeCommand().lower()
    if query == "none":
        speak("Sorry, I didn't catch that. Let's try again.")
        return

    api_url = f'https://api.api-ninjas.com/v1/recipe?query={query}'
    response = requests.get(api_url, headers={'X-Api-Key': api_key})
    
    if response.status_code == requests.codes.ok:
        recipes = response.json()
        if not recipes:
            speak("I couldn't find any recipes for that. Try a different one.")
            return
        
        speak(f"I found {len(recipes)} recipes. Here are their titles:")
        for idx, recipe in enumerate(recipes, start=1):
            print(f"{idx}. {recipe['title']}")  # Optional: print to console
            speak(f"{idx}. {recipe['title']}")
        
        # Use Tkinter to ask for the recipe number
        root = tk.Tk()
        root.withdraw()  # Hide the Tkinter root window
        selected_index = simpledialog.askstring("Input", "Please enter the number of the recipe you want:", parent=root)
        root.destroy()

        try:
            selected_index = int(selected_index) - 1
            selected_recipe = recipes[selected_index]
            # Speak the selected recipe details
            speak(f"You selected: {selected_recipe['title']}. Here is the recipe:")
            speak(f"Ingredients: {', '.join(selected_recipe['ingredients'])}")
            speak(f"Instructions: {selected_recipe['instructions']}")
        except (ValueError, IndexError):
            speak("Sorry, I didn't understand that. Let's try again later.")
    else:
        print("Error:", response.status_code, response.text)
        speak("I'm having trouble accessing the recipe service right now.")

save_directory = r"C:\Users\Yash\OneDrive\Pictures\Screenshots"


# Directory where new screenshots are saved
screenshot_directory = r"C:\Users\Yash\OneDrive\Pictures\Screenshots"
processed_directory = r"C:\Users\Yash\OneDrive\Pictures\ControlCenter4\OCR"

# Get the initial list of files in the directory
initial_files = os.listdir(screenshot_directory)

def find_latest_screenshot(directory):
    # List all files in the directory
    files = [os.path.join(directory, f) for f in os.listdir(directory)]
    # Filter out directories, only files
    files = [f for f in files if os.path.isfile(f)]
    # Sort files by last modified time
    latest_file = max(files, key=os.path.getmtime)
    return latest_file

def query_image_question_api(image_path, question):
    url = "https://api.edenai.run/v2/image/question_answer"
    headers = {"Authorization": f"Bearer {eden_api}"}  # Replace YOUR_API_TOKEN with your actual token

    files = {'file': open(image_path, 'rb')}
    data = {
        "providers": "alephalpha",
        "question": question,
        "fallback_providers": ""
    }

    response = requests.post(url, files=files, data=data, headers=headers)
    result = response.json()
    try:
        answers = result['alephalpha']['answers']
        print("Answers:", answers)
        return answers
    except KeyError:
        print("Error processing the API response:", result)
        return None


#Defines if error occured in opening browseer___________
def open_url_in_browser(url):
    try:
        # Use the 'start' command to open the URL in the default web browser
        subprocess.Popen(['start', url], shell=True)
    except Exception as e:
        print(f"An error occurred: {str(e)}")

# Function to open WhatsApp and search for contacts______________________________________________
def open_whatsapp_and_search(contact_name):
    # Open the Windows search bar (Win + S)
    pyautogui.hotkey("win", "s")
    
    # Type "WhatsApp" and press Enter to open it
    pyautogui.write("WhatsApp")
    pyautogui.press("enter")
    
    # Wait for WhatsApp to open (adjust the sleep time if needed)
    time.sleep(1)
    
    # Click on the search bar (adjust the coordinates based on your screen resolution)
    pyautogui.click(x=500, y=150)
    
    # Type the contact name you want to search for
    pyautogui.write(contact_name)
    pyautogui.press("enter")

def get_word_meaning(word):
    """Fetch the meaning of a word using the API."""
    word_encoded = requests.utils.quote(word)  # URL-encode the word
    api_url = f'https://api.api-ninjas.com/v1/dictionary?word={word_encoded}'
    response = requests.get(api_url, headers={'X-Api-Key': api_key})
    
    if response.status_code == requests.codes.ok:
        response_json = response.json()
        # Adjusted to handle the actual structure based on your debug print
        if response_json and 'definition' in response_json:
            return response_json['definition']  # Use 'definition' instead of 'meaning'
        else:
            print("Unexpected response structure:", response_json)
            return "Definition not found or unexpected response structure."
    else:
        print(f"Error fetching meaning: {response.status_code}")
        print("Response:", response.text)  # Log the error response for debugging
        return f"Error fetching meaning: {response.status_code}"

def handle_meaning_query(query):
    # Attempt to extract the target word directly following "meaning of"
    prefix = "meaning of"
    if prefix in query:
        # Find the position of the prefix and extract the word immediately after it
        start_index = query.find(prefix) + len(prefix) + 1  # +1 for the space after "of"
        word = query[start_index:].strip()
        # Handle cases where the word is followed by additional text (e.g., punctuation)
        word = word.split(' ', 1)[0].strip()
        if word:
            meaning = get_word_meaning(word)
            speak(f"The meaning of {word} is: {meaning}")
            return  # Exit the function after handling
    # If the prefix "meaning of" is not found or no word is extracted, ask the user for the word
    speak("Which word are you looking for the meaning of?")
    word = takeCommand().lower()
    if word:  # Check if 'word' is not an empty string
        meaning = get_word_meaning(word)
        speak(f"The meaning of {word} is: {meaning}")
    else:
        speak("Sorry, I didn't catch the word.")

def translate_text(source_language, target_language, text):
    """Translate the given text from the source language to the target language."""
    headers = {"Authorization": f"Bearer {eden_api}"}  # Correctly formatted header
    url = "https://api.edenai.run/v2/translation/automatic_translation"
    payload = {
        "providers": "google,amazon",
        "source_language": source_language,
        "target_language": target_language,
        "text": text,
        "fallback_providers": ""
    }
    response = requests.post(url, json=payload, headers=headers)
    if response.status_code == 200:
        result = json.loads(response.text)
        return result['google']['text']  # Assuming 'google' provider's result is desired
    else:
        print("Error:", response.status_code, response.text)
        return "Translation failed."
    
def get_user_input(prompt):
    """Get user input from the console."""
    print(prompt)
    return input(prompt)

def get_text_to_translate():
    """Use a Tkinter dialog to get the text to translate."""
    root = tk.Tk()
    root.withdraw()  # we don't want a full GUI, so keep the root window from appearing
    text = simpledialog.askstring("Input", "What text would you like to translate?")
    root.destroy()
    return text

def get_language_code(prompt="Select the language code:"):
    """Display a Tkinter dialog box for language selection and return the selected language code."""
    root = tk.Tk()
    root.withdraw()  # Hide the Tkinter root window


    # Dictionary of language codes and their corresponding languages
    languages = {
    'am': 'Amharic',
    'ar': 'Arabic',
    'bg': 'Bulgarian',
    'bn': 'Bengali',
    'cs': 'Czech',
    'da': 'Danish',
    'de': 'German',
    'el': 'Greek',
    'en': 'English',
    'es': 'Spanish',
    'et': 'Estonian',
    'fa': 'Persian',
    'fi': 'Finnish',
    'fr': 'French',
    'gu': 'Gujarati',
    'he': 'Hebrew',
    'hi': 'Hindi',
    'hu': 'Hungarian',
    'id': 'Indonesian',
    'it': 'Italian',
    'ja': 'Japanese',
    'ka': 'Georgian',
    'km': 'Khmer',
    'kn': 'Kannada',
    'ko': 'Korean',
    'lo': 'Lao',
    'lt': 'Lithuanian',
    'lv': 'Latvian',
    'ml': 'Malayalam',
    'ms': 'Malay',
    'my': 'Burmese',
    'ne': 'Nepali',
    'nl': 'Dutch',
    'no': 'Norwegian',
    'or': 'Odia',
    'pa': 'Punjabi',
    'pl': 'Polish',
    'pt': 'Portuguese',
    'ro': 'Romanian',
    'ru': 'Russian',
    'si': 'Sinhala',
    'sk': 'Slovak',
    'sl': 'Slovenian',
    'sr': 'Serbian',
    'sv': 'Swedish',
    'ta': 'Tamil',
    'te': 'Telugu',
    'th': 'Thai',
    'tr': 'Turkish',
    'uk': 'Ukrainian',
    'vi': 'Vietnamese',
}


   # Building the message for the dialog
    language_message = "\n".join([f"{code}: {lang}" for code, lang in languages.items()])

    # Asking the user to enter the language code
    language_code = simpledialog.askstring("Language Selection", f"{prompt}\n{language_message}")
    root.destroy()
    return language_code.lower() if language_code else None

def handle_translation():
    while True:  # Keep listening until a valid command is heard
        speak("Do you want to speak or type the text to translate?")
        method = takeCommand()
        if method:  # Proceed if we got a method (speak/type)
            method = method.lower()
            break  # Exit the loop if a command was successfully received
        else:
            speak("I didn't catch that. Let's try again.")

    # Use Tkinter dialog box for source language selection
    source_language = get_language_code("What is the source language?")
    if not source_language:
        speak("No source language selected.")
        return

    if 'speak' in method:
        while True:  # Keep listening until valid text is heard
            speak("Please speak the text you want to translate.")
            text_to_translate = takeCommand()
            if text_to_translate:
                break  # Exit the loop if text was successfully received
            else:
                speak("I didn't catch any text to translate. Let's try again.")
    else:
        text_to_translate = get_text_to_translate()  # Use Tkinter to input text for typing

    if text_to_translate:
        # Use Tkinter dialog box for target language selection
        target_language = get_language_code("Into which language do you want to translate?")
        if not target_language:
            speak("No target language selected.")
            return

        # Translate the text
        translation_result = translate_text(source_language, target_language, text_to_translate)
        speak(f"The translation is: {translation_result}")
    else:
        speak("No text was provided for translation.")


#------search wikipedia______________________________________________________________
def search_wikipedia(query):
    try:
        #
        results = wikipedia.summary(query, sentences=4, auto_suggest=False, redirect=False)
        speak("According to Wikipedia",)
        print(results)
        speak(results)
    except wikipedia.exceptions.DisambiguationError as e:
        options = e.options
        speak("There are multiple matching pages. Please choose one:")
        for i, option in enumerate(options, start=1):
            speak(f"{i}. {option}")
        choice = input("Enter the number of your choice: ")
        try:
            choice = int(choice)
            if 1 <= choice <= len(options):
                selected_option = options[choice - 1]
                results = wikipedia.summary(selected_option, sentences=2, auto_suggest=False, redirect=False)
                speak("According to Wikipedia")
                print(results)
                speak(results)
            else:
                speak("Invalid choice.")
        except ValueError:
            speak("Invalid input. Please enter a number.")
    except wikipedia.exceptions.PageError:
        speak(f"Sorry, I couldn't find any information about {query} on Wikipedia.")
    except Exception as e:
        speak("An error occurred while searching Wikipedia. Please try again later.")

#Perform clear action_______________________________________________________________
def clear_temporary_files():
    # Step 1: Open the Run dialog (Win + R)
    pyautogui.hotkey('win', 'r')
    time.sleep(1)  # Wait for the Run dialog to open

    # Step 2: Type %temp% and press Enter
    pyautogui.write('%temp%')
    pyautogui.press('enter')
    time.sleep(1)  # Wait for the temporary files folder to open

    # Step 3: Select all files (Ctrl + A)
    pyautogui.hotkey('ctrl', 'a')

    # Step 4: Delete selected files (Shift + Delete)
    pyautogui.hotkey('shift', 'delete')

    # Step 6: Close the folder (Alt + F4)
    pyautogui.hotkey('alt', 'f4')
    time.sleep(0.5)
    # Step 6: Close the folder (Alt + F4)
    pyautogui.hotkey('alt', 'f4')

# Function to perform OCR on a screenshot image___________________________________
def perform_ocr_on_screenshot(image_path):
    # Load the screenshot image
    time.sleep(1)
    screenshot = Image.open(image_path)

    # Perform OCR on the screenshot
    extracted_text = pytesseract.image_to_string(screenshot)

    return extracted_text

# Define chrome _____________
def search_in_chrome(query):
    # Check if Chrome is already running
    chrome_win = gw.getWindowsWithTitle("Google Chrome")

    if len(chrome_win) == 0:
        # If Chrome is not running, open it
        pyautogui.hotkey('win', 'r')
        pyautogui.write("chrome")
        pyautogui.press("enter")
        time.sleep(3)  # Wait for Chrome to open

    # Activate the Chrome window
    chrome_win = gw.getWindowsWithTitle("Google Chrome")
    if len(chrome_win) > 0:
        chrome_win[0].activate()
        chrome_win[0].maximize()

    # Open a new tab in Chrome (Ctrl+T)
        pyautogui.hotkey('ctrl', 't')
        time.sleep(1)  # Wait for the new tab to open
        
    else:
        # Handle the case where there are no Chrome windows
        speak("No Chrome windows found.")
        return
  # Perform the Google search in the new tab
    pyautogui.write(query)
    pyautogui.press('enter')

#Defines Function to control mouse and face landmarks___________________________________

def control_mouse_and_face(sensitivity=1.8):
        # Initialize the camera
    cam = cv2.VideoCapture(0)
    pyautogui.moveTo(881, 546,)

    # Initialize the face mesh model
    face_mesh = mp.solutions.face_mesh.FaceMesh(refine_landmarks=True)

     # Initialize the hands model
    hands = mp.solutions.hands.Hands(static_image_mode=False, max_num_hands=1, min_detection_confidence=0.5, min_tracking_confidence=0.5)

    # Get the screen size
    screen_w, screen_h = pyautogui.size()

    # Initialize the current mouse position
    current_x, current_y = pyautogui.position()

    while True:
        _, frame = cam.read()
        frame = cv2.flip(frame, 1)
        rgb_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)

         # Process hand landmarks
        results = hands.process(rgb_frame)
        if results.multi_hand_landmarks:
            hand_landmarks = results.multi_hand_landmarks[0]
            index_finger_tip = hand_landmarks.landmark[4].x * frame.shape[1], hand_landmarks.landmark[4].y * frame.shape[0]
            thumb_tip = hand_landmarks.landmark[8].x * frame.shape[1], hand_landmarks.landmark[8].y * frame.shape[0]
            
            # Calculate the distance between thumb and index finger tips
            distance = ((thumb_tip[0] - index_finger_tip[0])**2 + (thumb_tip[1] - index_finger_tip[1])**2)**0.5

            # If the distance is below a certain threshold, perform a click action
            if distance < 30:
                pyautogui.click()

        # Process face landmarks
        output = face_mesh.process(rgb_frame)
        landmark_points = output.multi_face_landmarks
        frame_h, frame_w, _ = frame.shape

        if landmark_points:
            landmarks = landmark_points[0].landmark
            for id, landmark in enumerate(landmarks[474:478]):
                x = int(landmark.x * frame_w)
                y = int(landmark.y * frame_h)
                cv2.circle(frame, (x, y), 3, (0, 255, 0))
                if id == 1:
                    screen_x = screen_w * landmark.x
                    screen_y = screen_h * landmark.y

                    # Calculate the change in eye position
                    delta_x = screen_x - current_x
                    delta_y = screen_y - current_y

                    # Increase sensitivity
                    delta_x *= sensitivity * 1.8
                    delta_y *= sensitivity * 1.8

                    # Update the current mouse position
                    current_x, current_y = screen_x, screen_y

                    # Move the mouse pointer
                    pyautogui.move(delta_x, delta_y)

            left = [landmarks[145], landmarks[159]]
            for landmark in left:
                x = int(landmark.x * frame_w)
                y = int(landmark.y * frame_h)
                cv2.circle(frame, (x, y), 3, (0, 255, 255))

        cv2.imshow('Eye Controlled Mouse', frame)

        
        # Check for the 'q' key press to exit the loop
        key = cv2.waitKey(1)
        if key == ord('q'):
            break

    # Release the camera and close the OpenCV window
    cam.release()
    cv2.destroyAllWindows()

def perform_ocr():
    global initial_files  # Assuming initial_files might be used globally
    initial_files = os.listdir(screenshot_directory)  # Initialize or reset initial_files before starting the scan

    speak("initialising scan, snip the region for scan and press ctrl+c to close scan")

    terminate_loop = False  # Initialize terminate_loop before entering the loop
    while not terminate_loop:
        current_files = os.listdir(screenshot_directory)
        new_files = [f for f in current_files if f not in initial_files]

        if new_files:
            # Assuming new_files has at least one new file
            screenshot_path = os.path.join(screenshot_directory, new_files[0])

            extracted_text = perform_ocr_on_screenshot(screenshot_path)
            speak("Extracted Text: " + extracted_text)

            search_query = extracted_text  # Prepare the search query
            webbrowser.open(f"https://www.google.com/search?q={search_query}")

            # Optionally move the screenshot to a "processed" directory
            os.rename(screenshot_path, os.path.join(processed_directory, new_files[0]))

            time.sleep(1)  # A short pause to avoid high CPU usage

        # Re-check initial_files for the next iteration to include newly added files
        initial_files = os.listdir(screenshot_directory)

        if keyboard.is_pressed('ctrl+c'):  # Needs to be run in a context where it doesn't block; consider try/except
            speak("Scanning closed...")
            terminate_loop = True
        
# Function to find and activate/click the search box in any application
def find_and_activate_search_box():
    search_box_names = ["search", "SearchBox", "search-box", "searchInput", "search_query"]

    # Loop through open windows
    for window in gw.getAllTitles():
        try:
            app_window = gw.getWindowsWithTitle(window)[0]
            app_window.activate()

            # Search for the search box by checking the control types
            for search_box_name in search_box_names:
                search_box = app_window.child_window(title_re=search_box_name, control_type="Edit")
                if search_box.exists():
                    # Activate or click the search box
                    search_box.click_input()
                    return True
        except IndexError:
            pass

    return False

# Function to listen and recognize speech

def takeCommand():
    r = sr.Recognizer()
    with sr.Microphone() as source:
        print("Listening...")
        r.adjust_for_ambient_noise(source, duration=1.5)
        audio = r.listen(source)
        
        # Check the audio level
        audio_level = audio.frame_data
        if sum(audio_level) / len(audio_level) < 100:  # 'threshold' to be defined based on testing
            print("Audio too quiet, please come closer to the microphone.")
            return None

    try:
        print("Recognizing...")
        query = r.recognize_google(audio, language='en-in')
        query = query.lower()
    except sr.UnknownValueError:
        print()
        query = None
    except Exception as e:
        print("Sorry, couldn't get you \n ^_^ ", str(e))
        query = None

    return query

def extract_search_query(query):
    # Extract the search query using a regular expression
    match = re.search(r"search on youtube\s*(.+)$", query, re.IGNORECASE)
    if match:
        query = match.group(1).strip()
    return query


# Define the path to the JSON file that will store the bot's knowledge base
knowledge_base_file = "D://knowledge_base.json"

# Load the bot's knowledge base from a JSON file
def load_knowledge_base(file_path):
    if os.path.exists(file_path):
        with open(file_path, 'r') as file:
            return json.load(file)
    else:
        return []

# Save the bot's knowledge base to a JSON file
def save_knowledge_base(file_path, knowledge_base):
    with open(file_path, 'w') as file:
        json.dump(knowledge_base, file, indent=4)

# Process user input and generate a random response based on matching keywords
def get_response(query, knowledge_base):
    for entry in knowledge_base:
        if any(keyword in query for keyword in entry["inputs"]):
            return random.choice(entry["responses"])
    return None

# Train the bot with new knowledge
def train_bot(query, knowledge_base):
    speak("I don't know how to respond to that. Could you teach me the correct response?", )

    # Initialize Tkinter root
    root = tk.Tk()
    root.withdraw()  # We don't want a full GUI, so keep the root window from appearing

    # Show an input box to the user and wait for a response
    user_response = simpledialog.askstring("Input", "Your response:", parent=root)
    if not user_response:  # Check if the response is None or empty
        speak("No problem", )
        return

    # Show another input box for keywords
    keywords = simpledialog.askstring("Input", "Please enter some keywords related to this response (separated by commas):", parent=root)
    if not keywords:  # Check if the keywords input is None or empty
        speak("No keywords received.", )
        return

    # Split keywords string into a list, strip whitespace, and ensure all keywords are lowercase
    keywords_list = [keyword.strip().lower() for keyword in keywords.split(',')]

    # Append new knowledge to the knowledge base
    knowledge_base.append({
        "inputs": [query] + keywords_list,
        "responses": [user_response]
    })

    # Save the updated knowledge base
    save_knowledge_base(knowledge_base_file, knowledge_base)
    speak("Thank you! I've learned something new.", )

    # List of predefined keywords or phrases
predefined_keywords = [
    "joke", "fact", "quote", "riddle", "trivia", "recipe", "wikipedia",
    "tab", "click mouse", "double click mouse", "youtube studio",
    "search on youtube", "google", "control", "time", "shut down", "restart",
    "lock", "open notepad and write", "minimise all", "maximize all",
    "take screenshot", "scan", "calculate", "speed test", "increase the volume",
    "decrease the volume", "mute", "refresh the page", "type", "whatsapp",
    "open", "search youtube", "close", "perform clear", "focus", "good bye",
    "who is","meaning","translate",
]

# Main function to run the assistant logics ,etc  --------------------------------------------------------------------------------------->
def main():
    speak("Gamora A.I activated", lily_voice_id) 
    knowledge_base = load_knowledge_base(knowledge_base_file)
    wishMe()  # Greet the user when starting up
     
    while True:
        query = takeCommand()
        if query is None:
            continue

        # Example function: search YouTube
        elif 'search on youtube' in query:
            # Remove the command part from the query
            query = query.replace("search on youtube", "").strip()

            # If the query is empty after removing the command, ask for more details
            if not query:
                # Extract the search query from the user's input
                speak("What would you like to search for on YouTube?", )
                query = takeCommand()
                query = extract_search_query(query)
                if query is None or query.lower() == "none":
                    speak("Sorry, I didn't catch that.", )
                    continue

            # Proceed to search on YouTube with the query provided directly or by the user after the prompt
            search_query = query.replace(' ', '+')  # Replace spaces with + for the URL
            url = f"https://www.youtube.com/results?search_query={search_query}"
            webbrowser.open(url)
            speak(f"Searching for {query} on YouTube.", )

        elif 'joke' in query:
            joke = fetch_joke(api_key)
            speak(joke)

        elif 'who is' in query:
            name = query.split('who is', 1)[1].strip()
            # Fetch details for the extracted name
            details = get_historical_figure_details(name)
            if details:
                # Assuming the API returns a list of figures, speak the first one's details
                figure = details[0]  # Adjust based on the actual API response structure
                description = figure.get('description', 'No description available.')
                speak(description)
            else:
                speak(f"I couldn't find information about {name}.")

        elif 'fact' in query:
            fact = get_fact()
            speak(fact) 
       
        elif 'meaning' in query:
            handle_meaning_query(query)

        elif 'info image' in query:
            # Assuming 'screenshot_directory' is defined earlier in your program
            latest_screenshot = find_latest_screenshot(screenshot_directory)
            print("Latest screenshot:", latest_screenshot)

            speak("What's your question about the image?")
            question = takeCommand().lower()  # Reusing your existing function for consistency
            if question:
                # Call the API function with the image and question
                answers = query_image_question_api(latest_screenshot, question)
                if answers:
                    # Speak or process the answers as needed
                    for answer in answers:
                        speak(answer)
            else:
                speak("Sorry, I didn't catch that.")
                
        elif 'quote' in query:
            quote_message = get_random_quote()
            speak(quote_message)

        elif 'riddle' in query:
            get_and_speak_riddle(api_key)

        elif 'trivia' in query:
            get_and_speak_trivia(api_key)    

        if 'recipe' in query:
            get_recipe(api_key)

        if 'translate' in query:
            handle_translation()
        
        if 'wikipedia' in query:
            speak('What would you like to search on Wikipedia?')
            query = takeCommand().lower()
            search_wikipedia(query)
        
        elif "tab" in query:
            pyautogui.hotkey('shift','ctrl', 'tab')

        elif "click mouse" in query:
           
            pyautogui.click()

        elif "double click mouse" in query:
           
            pyautogui.doubleClick()
       
        elif "youtube studio" in query:
            webbrowser.open("https://studio.youtube.com/channel/UCm18MyR2WhhAmkObCgOuocA")
        
        elif "google" in query:
            speak("What should I search?")
            query = takeCommand().lower()
            search_in_chrome(query)
                
        elif "control" in query:
            speak("press q to exit virtual control")
            control_mouse_and_face()
            
        elif 'time' in query:
            current_time = datetime.datetime.now()
            strTime = current_time.strftime("%I:%M %p")  # Format time as 12-hour clock with AM/PM
            speak(f"It's {strTime}")

        elif "shut down" in query:
          
            os.system("shutdown /s /t 5")
        
        elif "restart" in query:
            
            os.system("shutdown /r /t 5")

        elif "lock" in query:
            
            pyautogui.hotkey('win', 'm')
            time.sleep(1)
            pyautogui.hotkey('alt', 'f4')
            time.sleep(1)
            pyautogui.press('up')     
            time.sleep(1)
            pyautogui.press('enter')     


        elif "open notepad and write" in query:
           
            subprocess.Popen(["notepad.exe"])
            speak("Notepad is now open. Please speak up the text you want to write.")
            
            # Use a list to store the lines of text
            text_lines = []

            while True:
                text = takeCommand()
                
                # Check if the user wants to exit writing
                if "exit" in text:
                    break
                
                text_lines.append(text)

            # Combine the lines into a single string
            text_to_write = '\n'.join(text_lines)

            if text_to_write:
                # Ask whether to save the text or not
                speak("Do you want to save the text?")

                save_decision = takeCommand()

                if "yes" in save_decision:
                   # Specify the complete path to the new location
                    save_path = r"D:\Python\Gamora text file save\notepad_text.txt"
    
                        # Save the text to the specified location
                    with open(save_path, "w") as file:
                        file.write(text_to_write)
                    speak("The text has been saved in Notepad.")
                else:
                    speak("The text has not been saved.")

            else:
                speak("No text was provided.")

        elif  'minimise al' in query:
            pyautogui.hotkey('win','m')
            
        elif 'maximize all' in query:
            pyautogui.hotkey('win','shift','m')
        
        elif "take screenshot" in query:
            
            speak('so which name should i give to the file')
            name = takeCommand().lower()
            time.sleep(3)
            img = pyautogui.screenshot()
            img.save(f"C:\\Users\\Yash\\OneDrive\\Pictures\\Screenshots\\{name}.png")
            speak("screenshot saved")

        elif "scan" in query:
            perform_ocr()

        elif "calculate" in query:
            
            speak("Please say the calculation you'd like to perform.")
            calculation = takeCommand().lower()

            try:
                result = eval(calculation)  # Use the eval function to perform the calculation
                speak(f"The result of {calculation} is {result}")
            except Exception as e:
                speak("i apology, but it seems communication error!")

        elif "speed test" in query:
            speak("Checking")
            search_in_chrome("sp")
            pyautogui.press('enter')
            time.sleep(2)
            speak('dealing with network issue...')
            pyautogui.moveTo(863, 463,)
            pyautogui.click()
        
        elif "increase the volume" in query:
            pyautogui.press("volumeup")
            pyautogui.press("volumeup")
            pyautogui.press("volumeup")
            pyautogui.press("volumeup")
            pyautogui.press("volumeup")
            pyautogui.press("volumeup")
            pyautogui.press("volumeup")
            pyautogui.press("volumeup")
            pyautogui.press("volumeup")
            pyautogui.press("volumeup")
            pyautogui.press("volumeup")
            pyautogui.press("volumeup")
            pyautogui.press("volumeup")
            pyautogui.press("volumeup")
            pyautogui.press("volumeup")
        
        elif "decrease the volume" in query:
            pyautogui.press("volumedown")
            pyautogui.press("volumedown")
            pyautogui.press("volumedown")
            pyautogui.press("volumedown")
            pyautogui.press("volumedown")
            pyautogui.press("volumedown")
            pyautogui.press("volumedown")
            pyautogui.press("volumedown")
            pyautogui.press("volumedown")
            pyautogui.press("volumedown")
            pyautogui.press("volumedown")
            pyautogui.press("volumedown")
            pyautogui.press("volumedown")
            pyautogui.press("volumedown")
            pyautogui.press("volumedown")
        
        elif "mute" in query:
            pyautogui.press("volumemute")
        
        elif "refresh the page" in query:
            ()
            pyautogui.hotkey("win",'m')
            pyautogui.moveTo(1826, 519, 2)
            pyautogui.click(x=1826, y=519, clicks=1, interval=0, button='right')
            pyautogui.moveTo(1710, 625, 1)
            pyautogui.click(x=1710, y=625, clicks=1, interval=0, button='left')
            time.sleep(1.)
            pyautogui.moveTo(1826, 519, 2)
            pyautogui.click(x=1826, y=519, clicks=1, interval=0, button='right')
            pyautogui.moveTo(1710, 625, 1)
            pyautogui.click(x=1710, y=625, clicks=1, interval=0, button='left')
            time.sleep(1.)
            pyautogui.moveTo(1826, 519, 2)
            pyautogui.click(x=1826, y=519, clicks=1, interval=0, button='right')
            pyautogui.moveTo(1710, 625, 1)
            pyautogui.click(x=1710, y=625, clicks=1, interval=0, button='left')
            speak("refresh completed")
            pyautogui.hotkey('win','shift','m')

        elif "type" in query:
            speak("You can start typing. Say 'exit typing' to stop, 'add space' to add a space, and 'add line' to add a new line.")
            
            
            typing = True
            typed_text = ""

            while typing:
                spoken_text = takeCommand()
                
                if spoken_text.lower() == "stop typing":
                    break
                elif spoken_text.lower() == "give space":
                    pyautogui.press("space")
                elif spoken_text.lower() == "next line":
                    typed_text += "\n"
                    pyautogui.press("enter")
                elif spoken_text.lower() == "enter":
                    pyautogui.press("enter")
                elif spoken_text:
                    typed_text += spoken_text + " "
                    pyautogui.typewrite(spoken_text + " ")

            speak("Typing stopped.")


        elif  'whatsapp' in query:
        # Extract the contact name from the command
            contact_name = query.split("whatsapp", 1)[1].strip()
            open_whatsapp_and_search(contact_name)
        
        elif 'open' in query:
             
            keyword = query.split("open", 1)[1].strip()
        
            # Press the Windows key to open the Start menu
            pyautogui.press('win')
            
                # Wait for the Start menu to open
            pyautogui.sleep(1)

                # Type the spoken keyword in the Windows search box and press Enter
            pyautogui.write(keyword, interval=0.1)
            pyautogui.press('enter')

        elif 'search youtube' in query:
            speak("What would you like to watch?")
            qrry = takeCommand().lower()
            search_query = qrry.replace(' ', '+')  # Replace spaces with + for the URL
            url = f"https://www.youtube.com/results?search_query={search_query}"
            webbrowser.open(url)


        elif 'close' in query:
            pyautogui.hotkey('alt','f4','enter')


        elif 'perform clear' in query:
            speak('Clearing temporary files. This may take a moment.')
            clear_temporary_files()
            speak('Temporary files have been cleared.')

        elif 'focus' in query:
            speak("press q for exit focus mode ")
         # Initialize the VideoCapture object to capture video from the webcam (0 for the default camera)
            cap = cv2.VideoCapture(0)

            # Set the ROI (Region of Interest) dimensions
            roi_x, roi_y, roi_width, roi_height = 280, 280, 150, 150

            # Initialize the background subtraction object (useful for motion detection)
            fgbg = cv2.createBackgroundSubtractorMOG2()

            # Initialize a variable to keep track of the last time motion was detected
            last_motion_time = 0

            while True:
                # Read a frame from the camera
                ret, frame = cap.read()

                # Apply background subtraction to the frame
                fgmask = fgbg.apply(frame)

                # Crop the frame to the ROI
                roi_frame = frame[roi_y:roi_y + roi_height, roi_x:roi_x + roi_width]
                roi_fgmask = fgmask[roi_y:roi_y + roi_height, roi_x:roi_x + roi_width]

                # Threshold the foreground mask to get a binary image of the moving objects
                _, thresh = cv2.threshold(roi_fgmask, 128, 255, cv2.THRESH_BINARY)

                # Find contours in the binary image
                contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

                # Draw rectangles around the moving objects in the ROI
                for contour in contours:
                    if cv2.contourArea(contour) > 600:  # Adjust the area threshold as needed
                        x, y, w, h = cv2.boundingRect(contour)
                        cv2.rectangle(roi_frame, (x, y), (x + w, y + h), (0, 255, 0), 2)

                        # Get the current time
                        current_time = time.time()

                        # Check if 10 seconds have passed since the last motion detection
                        if current_time - last_motion_time > 10:
                            # Beep and print a message
                            winsound.Beep(1000, 500)  # Beep at 1000 Hz for 500 milliseconds
                            print("Motion detected. Please focus on studying.")
                            last_motion_time = current_time

                # Display the resulting frame with rectangles
                cv2.imshow('Motion Detection', frame)

                # Exit the loop if the 'q' key is pressed
                if cv2.waitKey(1) & 0xFF == ord('q'):
                    break

            # Release the VideoCapture and close all OpenCV windows
            cap.release()
            cv2.destroyAllWindows()


        elif "bye" in query:
            sys.exit()
    
    
        else:
                    # Check if the query matches any predefined keywords before prompting for training
            if any(keyword in query for keyword in predefined_keywords):
                # If a predefined keyword is found, you might want to handle it specifically
                # or simply acknowledge the command without training.
                # Example: speak("Command recognized. Executing.")
                pass  # Modify this part based on how you want to handle recognized commands
            else:
                # If no predefined keyword is found, proceed with the training prompt
                response = get_response(query, knowledge_base)
                if response:
                    speak(response)
                else:
                    train_bot(query, knowledge_base)
            response = get_response(query, knowledge_base)

if __name__ == "__main__":
    main()
